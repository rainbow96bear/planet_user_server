package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/rainbow96bear/planet_user_server/dto"
	"github.com/rainbow96bear/planet_user_server/graph/model"
	"github.com/rainbow96bear/planet_user_server/internal/mapper"
	"github.com/rainbow96bear/planet_user_server/middleware"
	"github.com/rainbow96bear/planet_user_server/utils"
	"github.com/rainbow96bear/planet_utils/pkg/logger"
)

// CreateCalendarEvent is the resolver for the createCalendarEvent field.
func (r *mutationResolver) CreateCalendarEvent(ctx context.Context, input model.CreateCalendarInput) (*model.Calendar, error) {
	token, err := middleware.ExtractAccessToken(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := utils.GetUserID(token)
	if err != nil {
		return nil, fmt.Errorf("invalid user id format: %w", err)
	}

	calendar := dto.ToCalendarModel(input, userID)

	created, err := r.CalendarService.CreateCalendarEvent(ctx, calendar)
	if err != nil {
		return nil, err
	}

	return dto.ToCalendarGraphQL(created), nil
}

// UpdateCalendarEvent is the resolver for the updateCalendarEvent field.
func (r *mutationResolver) UpdateCalendarEvent(
	ctx context.Context,
	eventID string,
	input model.UpdateCalendarInput,
) (*model.Calendar, error) {

	token, err := middleware.ExtractAccessToken(ctx)
	if err != nil {
		return nil, errors.New("unauthorized")
	}

	userID, err := utils.GetUserID(token)
	if err != nil {
		return nil, errors.New("unauthorized")
	}

	eventUUID, err := uuid.Parse(eventID)
	if err != nil {
		return nil, errors.New("invalid event id")
	}

	event, err := r.CalendarService.UpdateCalendarEvent(
		ctx,
		userID,
		eventUUID,
		input,
	)
	if err != nil {
		return nil, err
	}

	return mapper.ToCalendarGraphQL(event), nil
}

// DeleteCalendarEvent is the resolver for the deleteCalendarEvent field.
func (r *mutationResolver) DeleteCalendarEvent(ctx context.Context, eventID string) (bool, error) {
	token, err := middleware.ExtractAccessToken(ctx)
	if err != nil {
		return false, errors.New("unauthorized")
	}

	userID, err := utils.GetUserID(token)
	if err != nil {
		logger.Warnf("invalid token")
		return false, errors.New("unauthorized")
	}

	eventUUID, err := uuid.Parse(eventID)
	if err != nil {
		logger.Warnf("invalid eventID: %s", eventID)
		return false, errors.New("invalid event id")
	}

	if err := r.CalendarService.DeleteCalendarEvent(ctx, userID, eventUUID); err != nil {
		return false, err
	}

	return true, nil
}

// MyCalendarEvents is the resolver for the myCalendarEvents field.
func (r *queryResolver) MyCalendarEvents(ctx context.Context, year int32, month int32) ([]*model.Calendar, error) {
	logger.Infof("MyCalendarEvents start year=%d month=%d", year, month)
	defer logger.Infof("MyCalendarEvents end year=%d month=%d", year, month)

	token, err := middleware.ExtractAccessToken(ctx)
	if err != nil {
		return nil, errors.New("unauthorized")
	}

	userID, err := utils.GetUserID(token)
	if err != nil {
		logger.Warnf("invalid token")
		return nil, errors.New("unauthorized")
	}
	events, err := r.CalendarService.GetMyCalendarEvents(
		ctx,
		userID,
		int(year),
		int(month),
	)
	if err != nil {
		logger.Errorf("GetMyCalendarEvents failed: %v", err)
		return nil, errors.New("failed to get calendar events")
	}

	return mapper.ToCalendarGraphQLList(events), nil
}

// MyCalendarEvent is the resolver for the myCalendarEvent field.
func (r *queryResolver) MyCalendarEvent(
	ctx context.Context,
	eventID string,
) (*model.Calendar, error) {

	logger.Infof("MyCalendarEvent start eventID=%s", eventID)
	defer logger.Infof("MyCalendarEvent end eventID=%s", eventID)

	token, err := middleware.ExtractAccessToken(ctx)
	if err != nil {
		return nil, errors.New("unauthorized")
	}

	userID, err := utils.GetUserID(token)
	if err != nil {
		logger.Warnf("invalid token")
		return nil, errors.New("unauthorized")
	}

	eventUUID, err := uuid.Parse(eventID)
	if err != nil {
		logger.Warnf("invalid eventID: %s", eventID)
		return nil, errors.New("invalid event id")
	}

	event, err := r.CalendarService.GetEventDetailWithTodosByID(
		ctx,
		userID,
		eventUUID,
	)
	if err != nil {
		logger.Errorf("GetEventDetailWithTodosByID failed: %v", err)
		return nil, err
	}

	return mapper.ToCalendarGraphQL(event), nil
}

// MyCalendarEventsByDate is the resolver for the myCalendarEventsByDate field.
func (r *queryResolver) MyCalendarEventsByDate(ctx context.Context, date time.Time) ([]*model.Calendar, error) {
	logger.Infof("MyCalendarEventsByDate start date=%s", date.Format(time.RFC3339))
	defer logger.Infof("MyCalendarEventsByDate end date=%s", date.Format(time.RFC3339))

	token, err := middleware.ExtractAccessToken(ctx)
	if err != nil {
		return nil, errors.New("unauthorized")
	}

	userID, err := utils.GetUserID(token)
	if err != nil {
		logger.Warnf("invalid token")
		return nil, errors.New("unauthorized")
	}

	events, err := r.CalendarService.GetMyCalendarEventsByDate(
		ctx,
		userID,
		date, // time.Time 타입
	)
	if err != nil {
		logger.Errorf("GetMyCalendarEventsByDate failed: %v", err)
		return nil, errors.New("failed to get calendar events")
	}

	return events, nil
}

// UserCalendarEvents is the resolver for the userCalendarEvents field.
func (r *queryResolver) UserCalendarEvents(ctx context.Context, userID string, year int32, month int32) ([]*model.Calendar, error) {
	panic(fmt.Errorf("not implemented: UserCalendarEvents - userCalendarEvents"))
}
